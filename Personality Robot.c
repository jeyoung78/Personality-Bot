#pragma config(Sensor, S1,     HTAC,           sensorI2CCustom)
#pragma config(Sensor, S2,     touch,          sensorEV3_Touch)
#pragma config(Sensor, S4,     IR_Sensor,      sensorEV3_IRSensor, modeEV3IR_Seeker)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//includes
#include "hitechnic-accelerometer.h"



//global constants
const int CHASE_TIME = 15000;
const int LIVE_TIME = 10000;
const int ROBOT_LENGTH = 5;
const int TURN_OFF = 0;
const int HAPPY_STATE = 1;
const int SAD_STATE = 2;
const int ANGRY_STATE = 3;
const int ASLEEP_STATE = 4;
const int EXCITED_STATE = 5;
const int TIRED_STATE = 6;
const int TURN_TOL = 5;
const int BEHIND_IR_SENSOR = 50;

//function prototypes
int angryState();
int happyState();
int sadState();
int asleepState(tHTAC & accel);
int excitedState();
int tiredState();

//stops motors
void brake()
{
	motor[motorA] = motor[motorD] = 0;
}


//transition state
int goToState(int state, tHTAC & accel)//works
{

	if(state == HAPPY_STATE)
	{
		return happyState();
	}
	else if(state == SAD_STATE)
	{
		return sadState();
	}
	else if(state == ANGRY_STATE)
	{
		return angryState();
	}
	else if(state == ASLEEP_STATE)
	{
		return asleepState(accel);
	}
	else if(state == EXCITED_STATE)
	{
		return excitedState();
	}
	else if(state == TIRED_STATE)
	{
		return tiredState();
	}
	else
	{
		return TURN_OFF;
	}
}



//this code is looping during the alseep state
int asleepState(tHTAC & accel)//works
{
	readSensor(&accel);
	drawBmpfile(0,127,"Knocked out");
	clearTimer(T1);
	float xAccel = fabs(accel.x);
	float yAccel = fabs(accel.y); //initial value of x and y acceleration to determine change in acceleration
	//waits for motion
	while((fabs(accel.x- xAccel)+ fabs(accel.y- yAccel))/2 < 25)
	{
		setSoundVolume(75);
		playSoundFile("Snoring");

		if(time1[T1] > LIVE_TIME)
		{
			return TURN_OFF;
		}

		//reads and displays accel sensor
		readSensor(&accel);
		//displayTextLine(2, "   X    Y    Z");
    //displayTextLine(3, "%4d %4d %4d", accelerometer.x, accelerometer.y, accelerometer.z);
		//checks if accel is above 50 in x or y
		if((fabs(accel.x- xAccel)+ fabs(accel.y- yAccel))/2 > 75)
		{
			//returns an int value of 3
			clearSounds();
			return ANGRY_STATE;
		}
	}
	//defaults to happy state
	clearSounds();
	setSoundVolume(75);
	playSoundFile("Hello");
	wait1Msec(500);
	playSoundFile("Good");
	wait1Msec(500);
	playSoundFile("Morning");
	wait1Msec(500);
	return HAPPY_STATE;

}

int happyState()
{
	clearSounds();
	float heading = getIRBeaconDirection(IR_Sensor);

	while((heading > TURN_TOL|| heading < -TURN_TOL)|| getIRBeaconStrength(IR_Sensor) > BEHIND_IR_SENSOR)
	{
		heading = getIRBeaconDirection(IR_Sensor);

		if (heading > 0)
		{
			motor[motorA] = -30;
			motor[motorD] = 30;
		}
		else if (heading < 0)
		{
			motor[motorA] = 30;
			motor[motorD] = -30;
		}
	}
	brake();
	const int WAVE_DEG = 196;
	drawBmpfile(0,127,"Big smile");
	for(int count = 0; count <= 5; count++)
	{
		while(nMotorEncoder[motorB] < WAVE_DEG)
		{
			motor[motorB] = 20;
		}
		while(nMotorEncoder[motorB] > 0)
		{
			motor[motorB] = -20;
		}
	}
	motor[motorB] = 0;

	clearSounds();
	return EXCITED_STATE;
}

int angryState()//works
{
	clearSounds();

	float heading = getIRBeaconDirection(IR_Sensor);

	while((heading > TURN_TOL|| heading < -TURN_TOL)|| getIRBeaconStrength(IR_Sensor) > BEHIND_IR_SENSOR)
	{
		heading = getIRBeaconDirection(IR_Sensor);

		if (heading > 0)
		{
			motor[motorA] = -5;
			motor[motorD] = 5;
		}
		else if (heading < 0)
		{
			motor[motorA] = 5;
			motor[motorD] = -5;
		}
	}

	brake();

	drawBmpfile(0,127,"Angry");
	setSoundVolume(75);
	playSoundFile("T-rex roar");
	wait1Msec(2000);
	//chase beacon portion
	clearTimer(T1);

		while(getIRBeaconStrength(IR_Sensor) > ROBOT_LENGTH)
		{
			//gets dist to move
			heading = getIRBeaconDirection(IR_Sensor);

			while(heading > TURN_TOL || heading < -TURN_TOL)
			{
				heading = getIRBeaconDirection(IR_Sensor);

				if (heading > 0)
				{
					motor[motorA] = -30;
					motor[motorD] = 30;
				}
				else if (heading < 0)
				{
					motor[motorA] = 30;
					motor[motorD] = -30;
				}
			}

			motor[motorA] = motor[motorD] = 100;

			//checks if robot hit the beacon yet
			if(SensorValue[touch] == 1)
			{
				brake();
				clearSounds();
				return EXCITED_STATE;
			}

			if(time1[T1] > CHASE_TIME)
			{
				brake();
				clearSounds();
				return SAD_STATE;
			}

		}


	brake();


	//defaults to sadState
	clearSounds();
	return SAD_STATE;
	///////////////////////

}

int excitedState()
{
	drawBmpfile(0,127,"Crazy 1");
	clearSounds();
	clearTimer(T1);


	while(time1[T1] < LIVE_TIME)
	{
		motor[motorA] = 100;
		motor[motorD] = -100;

	}
	brake();
	return TIRED_STATE;
}


int sadState()
{
	drawBmpfile(0,127,"Hurt");
	clearTimer(T1);
	clearSounds();

	while(time1[T1] < LIVE_TIME)
	{
		setSoundVolume(75);
		playSoundFile("Crying");
		if(getIRBeaconStrength(IR_Sensor) < BEHIND_IR_SENSOR)
		{
			motor[motorA] = -50;
			motor[motorD] = 50;
		}
		else
		{
			brake();
		}
	}
	brake();
	clearSounds();
	return TIRED_STATE;
}

int tiredState()
{
	clearSounds();
	drawBmpfile(0,127,"Tired middle");
	clearTimer(T1);
	while(time1[T1] < LIVE_TIME)
	{


		if(SensorValue[touch] == 1)
		{
			clearSounds();
		 	return HAPPY_STATE;
		}
	}
	//goes to sleep if tired for over 10 seconds
	clearSounds();
	return ASLEEP_STATE;
}


task main()
{


	// Create struct to hold sensor data
  tHTAC accelerometer;

  // Initialise and configure struct and port
  initSensor(&accelerometer, S1);
	//sensorMode[IR_Sensor] =
  //test if getting values
  if (!readSensor(&accelerometer))
  {
    displayTextLine(4, "ERROR!!");
    sleep(2000);
    stopAllTasks();
  }

  clearSounds();

	int transition = 0;
	//initial asleep state enter point
  transition = asleepState(accelerometer);

  while(transition != TURN_OFF)
	{
  	transition = goToState(transition,accelerometer);

	}

	setSoundVolume(75);
	playSoundFile("Power down");





}
